<script lang="ts">
  // ===== ДАННЫЕ ===============================================================
  // Импорты строго под твои алиасы:
  import normal from '@/data/mutants/normal.json';
  import bronze from '@/data/mutants/bronze.json';
  import silver from '@/data/mutants/silver.json';
  import gold from '@/data/mutants/gold.json';
  import platinum from '@/data/mutants/platinum.json';
  import orbsAll from '@/data/materials/orbs.json';

  export let label = '';
  export let value: string | number = '';

  // ===== ВСПОМОГАТЕЛЬНЫЕ ТИПЫ ===============================================
  type StarKey = 'normal'|'bronze'|'silver'|'gold'|'platinum';
  type GeneKey = ''|'A'|'B'|'C'|'D'|'E'|'F';

  // ===== СЛОВАРИ =============================================================
  // Имена генов по твоей терминологии (для сортировки/всплывающих подсказок)
  const GENE_RU: Record<GeneKey,string> = {
    '': 'Все',
    A: 'Кибер',     // жёлтая
    B: 'Зомби',     // зелёная (у тебя так принято)
    C: 'Рубака',    // красная
    D: 'Зверь',     // коричневая
    E: 'Галактик',  // синяя
    F: 'Мифик'      // фиолетовая
  };

  // Иконки генов (пути из /public/genes) — подтверждены в репозитории
  const GENE_ICON: Record<GeneKey,string> = {
    '': '/genes/icon_gene_all.png',
    A: '/genes/icon_gene_a.png',
    B: '/genes/icon_gene_b.png',
    C: '/genes/icon_gene_c.png',
    D: '/genes/icon_gene_d.png',
    E: '/genes/icon_gene_e.png',
    F: '/genes/icon_gene_f.png'
  };

  // Иконки звёзд (пути из /public/stars) — подтверждены в репозитории
  const STAR_ICON: Record<StarKey,string> = {
    normal:   '/stars/no_stars.png',
    bronze:   '/stars/star_bronze.png',
    silver:   '/stars/star_silver.png',
    gold:     '/stars/star_gold.png',
    platinum: '/stars/star_platinum.png'
  };

  // ===== ПОДГОТОВКА ДАННЫХ ===================================================
  // Датасеты по звёздам
  const DATA_BY_STAR: Record<StarKey, any[]> = {
    normal, bronze, silver, gold, platinum
  };

  // Быстрые индексы по id для каждого уровня звёзд
  const MAP_BY_STAR: Record<StarKey, Map<string, any>> = {
    normal:   new Map(normal.map((m:any)   => [idOf(m), m])),
    bronze:   new Map(bronze.map((m:any)   => [idOf(m), m])),
    silver:   new Map(silver.map((m:any)   => [idOf(m), m])),
    gold:     new Map(gold.map((m:any)     => [idOf(m), m])),
    platinum: new Map(platinum.map((m:any) => [idOf(m), m]))
  };

  // Определяем id записи (в разных JSON могли быть разные поля)
  function idOf(x:any): string {
    return String(x?.id ?? x?.specimen ?? x?.spriteId ?? x?.key ?? '').trim();
  }

  // Читаем ген-код
  function geneCodeOf(x:any): string {
    if (typeof x?.gene === 'string') return x.gene;
    if (typeof x?.gene_code === 'string') return x.gene_code;
    if (Array.isArray(x?.genes) && typeof x.genes[0] === 'string') return x.genes[0];
    return '';
  }

  // Для превью — человекочитаемое имя
  function nameOf(x:any): string {
    return String(x?.name ?? x?.name_ru ?? x?.title ?? idOf(x) ?? '').trim();
  }

  // Выбор полной текстуры по текущей звезде (ищем в массиве image)
  function pickFullTexture(item:any, star:StarKey): string {
    const raw = item?.image;
    const arr = Array.isArray(raw) ? raw : (raw ? [raw] : []);
    const want = star === 'normal' ? 'normal' : star;
    // пытаемся найти текстуру со словом нужной звезды
    let chosen = arr.find((p:string) => typeof p === 'string'
      && p.toLowerCase().includes(want))
      // иначе ищем любую .png
      ?? arr.find((p:string) => typeof p === 'string' && p.toLowerCase().endsWith('.png'))
      ?? '';
    chosen = String(chosen).replace(/^\/*/,''); // без ведущих слэшей
    return chosen ? `/${chosen}` : '';
  }

  // ===== UI СОСТОЯНИЕ ========================================================
  let sortMode: 'name'|'gene' = 'name';
  let geneFilter: GeneKey = '';
  let search = '';

  let starSel: StarKey = 'normal';
  let level = 30; // пользователь вводит числом

  // Выбор текущего мутанта
  let current: any = null;

  // Орб-слоты: правила
  function slotsForType(type: string): { kind:'basic'|'special' }[] {
    const t = String(type ?? '').toLowerCase();
    if (t === 'heroic') return [
      {kind:'basic'},{kind:'basic'},{kind:'basic'},{kind:'basic'},{kind:'special'}
    ];
    if (t === 'default') return [
      {kind:'basic'},{kind:'basic'},{kind:'special'}
    ];
    return [
      {kind:'basic'},{kind:'basic'},{kind:'basic'},{kind:'special'}
    ];
  }

  // Список доступных орбов из materials/orbs.json.
  // В файле встречаются разные схемы полей, поэтому агрегатор максимально гибкий.
  type Orb = { id:string; name?:string; title?:string; type?:string; effects?:any; [k:string]:any };
  const allOrbs: Orb[] = Array.isArray(orbsAll) ? orbsAll as Orb[] : [];

  // детектим тип: special vs basic
  function orbKind(o:Orb): 'special'|'basic' {
    const id = String(o.id ?? '').toLowerCase();
    const t  = String(o.type ?? '').toLowerCase();
    if (t.includes('special') || id.includes('special') || id.startsWith('sp_')) return 'special';
    return 'basic';
  }
  // путь к иконке орба
  function orbIcon(o:Orb): string {
    const kind = orbKind(o);
    return `/orbs/${kind}/${o.id}.png`; // текстуры лежат в public/orbs/basic|special/<id>.png
  }

  // Агрегатор эффектов орбов → {hpPct, atkPct, speedPct, creditPct, ability:{...}}
  type OrbSum = { hpPct:number; atkPct:number; speedPct:number; creditPct:number; ability: Record<string, number> };
  function sumOrbs(orbs: Orb[]): OrbSum {
    const sum: OrbSum = { hpPct:0, atkPct:0, speedPct:0, creditPct:0, ability:{} };
    for (const o of orbs) {
      const obj = (o.effects && typeof o.effects === 'object') ? o.effects : o;
      for (const [k0, v] of Object.entries(obj)) {
        const k = k0.toLowerCase();
        if (typeof v !== 'number') continue;
        if (k.includes('hp')      && k.includes('percent')) { sum.hpPct     += v; continue; }
        if ((k.includes('atk')||k.includes('attack')) && k.includes('percent')) { sum.atkPct += v; continue; }
        if (k.includes('speed')   && k.includes('percent')) { sum.speedPct  += v; continue; }
        if (k.includes('credit')  && k.includes('percent')) { sum.creditPct += v; continue; }
        if (k.startsWith('ability_') && k.endsWith('percent')) {
          const key = k.substring('ability_'.length, k.length - 'percent'.length);
          sum.ability[key] = (sum.ability[key] ?? 0) + v;
        }
      }
    }
    return sum;
  }

  // Текущий набор орбов в слотах
  let slotDefs = slotsForType(current?.type);
  $: slotDefs = slotsForType(current?.type); // пересчёт при смене мутанта/типа
  let slotOrbs: (Orb | null)[] = [];
  $: slotOrbs = Array.from({length: slotDefs.length}, (_,i)=>slotOrbs?.[i] ?? null);

  // Выбор орба (простое выпадающее меню рядом со слотом, без document.* чтобы не ловить SSR)
  let orbPickerOpenIndex: number | null = null;
  function pickOrb(idx:number, o: Orb) {
    slotOrbs[idx] = o;
    orbPickerOpenIndex = null;
  }
  function clearOrb(idx:number) { slotOrbs[idx] = null; }

  // ===== ВЫБОР СПИСКА МУТАНТОВ ===============================================
  const baseList: any[] = Array.isArray(normal) ? normal : [];

  // Фильтрация
  function passesGene(m:any): boolean {
    if (!geneFilter) return true;
    const g = geneCodeOf(m).toUpperCase().split('').sort().join(''); // AA, AB и т.д.
    return g.includes(geneFilter);
  }
  function passesSearch(m:any): boolean {
    const q = search.trim().toLowerCase();
    if (!q) return true;
    return nameOf(m).toLowerCase().includes(q);
  }

  // Сортировка
  function sortFn(a:any,b:any): number {
    if (sortMode === 'name') {
      return nameOf(a).localeCompare(nameOf(b),'ru');
    } else {
      const ga = geneCodeOf(a);
      const gb = geneCodeOf(b);
      if (ga === gb) return nameOf(a).localeCompare(nameOf(b),'ru');
      return ga.localeCompare(gb,'ru');
    }
  }

  $: filtered = baseList.filter(passesGene).filter(passesSearch).sort(sortFn);

  // ===== РАСЧЁТ СТАТОВ =======================================================
  // Читаем мультипликатор из звёздного датасета (если нет — 1)
  function starMultiplier(id:string, star:StarKey): number {
    if (star === 'normal') return 1;
    const rec = MAP_BY_STAR[star].get(id);
    const mul = Number(rec?.multiplier ?? rec?.star_multiplier ?? 1);
    return isFinite(mul) && mul>0 ? mul : 1;
  }

  // Берём базовые значения (на 1 уровне) из normal.json,
  // а для звёзд умножаем на multiplier из соответствующего файла.
  function baseHP1(m:any, star:StarKey): number {
    const id = idOf(m);
    // многие твои JSON'ы имеют base_stats.lvl1.hp, но делаем устойчиво:
    const hp1 = Number(m?.base_stats?.lvl1?.hp ?? m?.hp_lvl1 ?? m?.hp1 ?? m?.hp ?? 0);
    const mul = starMultiplier(id, star);
    return hp1 * mul;
  }
  function baseATK(m:any, star:StarKey, key:'atk1'|'atk1p'|'atk2'|'atk2p'): number {
    const id = idOf(m);
    const raw =
      Number(m?.base_stats?.lvl1?.[key] ??
             m?.[key] ??
             m?.[`${key}_base`] ??
             0);
    const mul = starMultiplier(id, star);
    return raw * mul;
  }

  // Формула из ТЗ:
  //   x * (y/10 + 0.9)
  // где x — базовое значение на 1 уровне (с учётом звезды),
  // y — выбранный уровень.
  function scaleByLevel(x:number, y:number): number {
    return x * (y/10 + 0.9);
  }

  // Применяем бонусы от орбов (%)
  function applyOrbPct(value:number, pct:number): number {
    return value * (1 + (pct/100));
  }

  // Реактивный пересчёт
  $: stats = computeStats(current, starSel, level, slotOrbs);

  function computeStats(m:any, star:StarKey, lvl:number, slots:(Orb|null)[]) {
    if (!m) return null;

    const id = idOf(m);

    // Суммируем орбы по типу слотов — учитываем только реально выбранные
    const effects = sumOrbs(slots.filter(Boolean) as Orb[]);

    // HP
    const hp1 = baseHP1(m, star);
    let hp = scaleByLevel(hp1, lvl);
    hp = applyOrbPct(hp, effects.hpPct);

    // Атаки
    const a1base  = (lvl < 10) ? baseATK(m, star, 'atk1')  : baseATK(m, star, 'atk1p');
    const a2base  = (lvl < 15) ? baseATK(m, star, 'atk2')  : baseATK(m, star, 'atk2p');
    let atk1 = applyOrbPct(scaleByLevel(a1base, lvl), effects.atkPct);
    let atk2 = applyOrbPct(scaleByLevel(a2base, lvl), effects.atkPct);

    // Прочее — скорость/кредиты можно вывести из normal.json, если нужно, и тоже умножить на speed/credit
    // Названия абилок
    const ability1 = String(m?.name_attack1 ?? m?.attack1_name ?? '').trim();
    const ability2 = String(m?.name_attack2 ?? m?.attack2_name ?? '').trim();

    // Бинго/Тир
    const bingo = m?.bingo;
    const tier  = m?.tier ?? m?.rank ?? m?.category ?? '';

    return {
      id, name: nameOf(m),
      hp: Math.round(hp),
      atk1: Math.round(atk1),
      atk2: Math.round(atk2),
      ability1, ability2,
      bingo, tier
    };
  }

  // ===== ОБРАБОТЧИКИ UI ======================================================
  function selectMutant(m:any) {
    current = m;
    // сбрасываем слоты под его тип
    slotDefs = slotsForType(current?.type);
    slotOrbs = slotDefs.map(()=>null);
    // по умолчанию показываем нормальную версию
    starSel = 'normal';
  }

  // Список орбов по требуемому слоту
  function orbsFor(kind:'basic'|'special'): Orb[] {
    return allOrbs.filter(o => orbKind(o) === kind);
  }

  // Утилиты для отображения
  function fullTextureOf(m:any): string {
    return pickFullTexture(m, starSel) || ''; // если пусто, оставим без картинки
  }
  function geneIconsOf(m:any): string[] {
    const g = geneCodeOf(m).toUpperCase().split('');
    return g.map(x => GENE_ICON[x as GeneKey]).filter(Boolean);
  }
</script>


<!-- ============================= ЛЕВАЯ КОЛОНКА ============================= -->
<div class="grid grid-cols-12 gap-4">
  <aside class="col-span-12 md:col-span-4 lg:col-span-3">
    <!-- Фильтр по генам -->
    <div class="p-3 rounded-xl bg-slate-800/60 border border-white/10 mb-3">
      <div class="flex items-center gap-2 flex-wrap">
        {#each (['', 'C','A','E','B','F','D'] as GeneKey[]) as g}
          <button
            class="px-2 py-1 rounded bg-slate-700/70 hover:bg-slate-700 ring-1 ring-white/10 flex items-center gap-1"
            class:selected={geneFilter===g}
            on:click={() => geneFilter = (geneFilter===g?'':g)}
            title={GENE_RU[g] ?? ''}>
            <img src={GENE_ICON[g]} alt={GENE_RU[g] ?? ''} class="w-5 h-5"/>
          </button>
        {/each}
      </div>
    </div>

    <!-- Поиск + переключатель сортировки -->
    <div class="p-3 rounded-xl bg-slate-800/60 border border-white/10 mb-3">
      <input
        class="w-full rounded bg-slate-900/70 border border-white/10 px-3 py-2 text-sm mb-2"
        placeholder="Введите имя мутанта"
        bind:value={search}
      />
      <div class="flex gap-2">
        <button class:active={sortMode==='name'}
                class="px-3 py-1.5 rounded bg-slate-700 hover:bg-slate-600 ring-1 ring-white/10"
                on:click={() => sortMode='name'}>Имя [А–Я]</button>
        <button class:active={sortMode==='gene'}
                class="px-3 py-1.5 rounded bg-slate-700 hover:bg-slate-600 ring-1 ring-white/10"
                on:click={() => sortMode='gene'}>Ген</button>
      </div>
    </div>

    <!-- Список мутантов -->
    <div class="rounded-xl bg-slate-800/60 border border-white/10 overflow-hidden">
      <div class="max-h-[70vh] overflow-auto divide-y divide-white/5">
        {#each filtered as m (idOf(m))}
          <button class="w-full flex items-center gap-3 px-3 py-2 hover:bg-slate-700/50 text-left"
                  on:click={() => selectMutant(m)}>
            <div class="w-10 h-10 shrink-0 rounded bg-slate-900/50 ring-1 ring-white/10 grid place-items-center">
              <!-- маленький значок: возьмём specimen/иконку если есть, иначе первая картинка -->
              <img src={pickFullTexture(m, 'normal')} alt="" class="max-w-full max-h-full object-contain"/>
            </div>
            <div class="min-w-0 grow">
              <div class="text-sm font-semibold truncate">{nameOf(m)}</div>
              <div class="flex items-center gap-1 mt-0.5">
                {#each geneIconsOf(m) as gi}
                  <img src={gi} alt="" class="w-4 h-4"/>
                {/each}
              </div>
            </div>
          </button>
        {/each}
      </div>
    </div>
  </aside>

  <!-- ============================ ПРАВАЯ КОЛОНКА =========================== -->
  <section class="col-span-12 md:col-span-8 lg:col-span-9">
    <div class="rounded-2xl bg-slate-800/60 border border-white/10 p-4 md:p-6">
      {#if current}
        <!-- Заголовок + звёзды -->
        <div class="flex items-center justify-between gap-4">
          <h2 class="text-2xl md:text-3xl font-extrabold">{nameOf(current)}</h2>
          <div class="flex items-center gap-2">
            {#each (['normal','bronze','silver','gold','platinum'] as StarKey[]) as s}
              <button
                class="p-1.5 rounded bg-slate-900/60 ring-1 ring-white/10 hover:bg-slate-900"
                aria-label={s}
                on:click={() => starSel = s}>
                <img src={STAR_ICON[s]} alt={s} class="w-7 h-7"/>
              </button>
            {/each}
          </div>
        </div>

        <!-- Полная текстура + иконки генов -->
        <div class="mt-4 flex flex-col md:flex-row gap-6">
          <div class="grow flex flex-col items-center">
            <div class="relative w-full max-w-[380px]">
              <img src={fullTextureOf(current)} alt={nameOf(current)} class="w-full object-contain rounded-xl ring-1 ring-white/10 bg-slate-900/50"/>
              <div class="absolute left-2 top-2 flex gap-1">
                {#each geneIconsOf(current) as gi}
                  <img src={gi} alt="" class="w-6 h-6 drop-shadow"/>
                {/each}
              </div>

              <!-- Слоты под сферы — ровно 1 ряд под картинкой -->
              <div class="mt-3 flex items-center justify-center gap-3">
                {#each slotDefs as s, i}
                  <div class="relative">
                    <!-- ячейка -->
                    <button class="w-12 h-12 grid place-items-center rounded-lg ring-1 ring-white/10 bg-slate-900/70 hover:bg-slate-900"
                            on:click={() => orbPickerOpenIndex = (orbPickerOpenIndex===i ? null : i)}>
                      {#if slotOrbs[i]}
                        <img src={orbIcon(slotOrbs[i]!)} alt="" class="w-10 h-10 object-contain"/>
                      {:else}
                        <img src={s.kind==='special' ? '/orbs/special/orb_slot_spe.png' : '/orbs/basic/orb_slot.png'} alt="" class="w-10 h-10 object-contain opacity-80"/>
                      {/if}
                    </button>

                    <!-- выпадающий список -->
                    {#if orbPickerOpenIndex === i}
                      <div class="absolute z-10 mt-1 left-0 w-64 max-h-72 overflow-auto p-2 rounded-lg bg-slate-900 ring-1 ring-white/10">
                        <div class="flex justify-between items-center mb-2">
                          <strong class="text-sm">{s.kind==='special' ? 'Special' : 'Basic'} Orbs</strong>
                          <button class="text-xs px-2 py-1 rounded bg-slate-800 hover:bg-slate-700" on:click={() => clearOrb(i)}>Очистить</button>
                        </div>
                        {#each orbsFor(s.kind) as o (o.id)}
                          <button class="w-full flex items-center gap-2 px-2 py-1 rounded hover:bg-slate-800"
                                  on:click={() => pickOrb(i,o)}>
                            <img src={orbIcon(o)} alt="" class="w-6 h-6"/>
                            <span class="text-sm truncate">{o.title ?? o.name ?? o.id}</span>
                          </button>
                        {/each}
                      </div>
                    {/if}
                  </div>
                {/each}
              </div>
            </div>
          </div>

          <!-- Панель статов -->
          <div class="w-full max-w-[460px]">
            <!-- Уровень -->
            <div class="mb-3">
              <label class="block text-sm opacity-80 mb-1">Уровень</label>
              <input type="number" min="1" max="1000" step="1" bind:value={level}
                     class="w-32 px-3 py-1.5 rounded bg-slate-900 ring-1 ring-white/10"/>
            </div>

            {#if stats}
              <div class="space-y-2">
                <Row label="Редкость" value={starSel === 'normal' ? 'Обычная' : starSel}/>
                <Row label="HP"       value={stats.hp.toLocaleString('ru-RU')}/>
                <Row label="Атака 1"  value={stats.atk1.toLocaleString('ru-RU')}/>
                <Row label="Атака 2"  value={stats.atk2.toLocaleString('ru-RU')}/>
                {#if stats.ability1}<Row label="Способность 1" value={stats.ability1}/>{/if}
                {#if stats.ability2}<Row label="Способность 2" value={stats.ability2}/>{/if}
                {#if stats.tier}<Row label="Тир" value={stats.tier}/>{/if}
                {#if stats.bingo}<Row label="Бинго" value={Array.isArray(stats.bingo)? stats.bingo.join(', '): String(stats.bingo)}/>{/if}
              </div>
            {:else}
              <div class="opacity-70">Выберите мутанта слева.</div>
            {/if}
          </div>
        </div>
      {:else}
        <div class="opacity-70">Выберите мутанта слева.</div>
      {/if}
    </div>
  </section>
</div>

