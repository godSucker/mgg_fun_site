diff --git a/src/components/MutantsBrowser.svelte b/src/components/MutantsBrowser.svelte
index a4ec82a9d1e69c5535ad16707aafcfd7b46c0581..579371f28c63d2ba41a0f9e7c8fba7b14cdf27cc 100644
--- a/src/components/MutantsBrowser.svelte
+++ b/src/components/MutantsBrowser.svelte
@@ -1,62 +1,143 @@
 <script lang="ts">
   import MutantModal from './MutantModal.svelte';
   import { TYPE_RU, geneLabel, bingoLabel } from '@/lib/mutant-dicts';
 
   // Пропсы
   export let items: any[] = [];     // normal + bronze + silver + gold + platinum
   export let skins: any[] = [];     // skins.json -> specimens[]
   export let title = '';
   export let bingoIndex: string[] = [];
   // Мемо-кэш для фильтрации/сортировки (не влияет на UI)
   const _cache = new Map<string, any[]>();
   function memo<T>(key: string, calc: () => T): T {
     if (_cache.has(key)) return _cache.get(key) as T;
     const v = calc();
     _cache.set(key, v as any);
     return v;
   }
 
 
   // =========================
   // НОРМАЛИЗАЦИЯ ДАННЫХ SKINS
   // =========================
-  function mapSkin(s: any) {
-    return {
-      id: s?.id,
-      name: s?.name,
-      genes: s?.genes,
-      base_stats: s?.base_stats,
-      image: s?.image,
-      type: s?.type ?? 'default',
+  const baseId = (id: any) =>
+    String(id ?? '')
+      .toLowerCase()
+      .replace(/_+(?:normal|bronze|silver|gold|platinum|plat).*$/i, '');
+
+  type BaseMap = Map<string, any>;
+  function buildBaseMap(list: any[]): BaseMap {
+    const map: BaseMap = new Map();
+    for (const item of Array.isArray(list) ? list : []) {
+      const key = baseId(item?.id);
+      if (!key) continue;
+      const id = String(item?.id ?? '').toLowerCase();
+      const isNormal = !/_+(?:bronze|silver|gold|platinum|plat)\b/.test(id);
+      if (!map.has(key) || isNormal) {
+        map.set(key, item);
+      }
+    }
+    return map;
+  }
+
+  function hasBingo(val: any): boolean {
+    if (!val) return false;
+    if (Array.isArray(val)) return val.length > 0;
+    if (typeof val === 'object') return Object.keys(val).length > 0;
+    return false;
+  }
+
+  function mergeBaseStats(baseStats: any, override: any) {
+    if (!baseStats && !override) return undefined;
+    const result = { ...(baseStats ?? {}) };
+    if (baseStats?.lvl1 || override?.lvl1) {
+      result.lvl1 = { ...(baseStats?.lvl1 ?? {}), ...(override?.lvl1 ?? {}) };
+    }
+    if (baseStats?.lvl30 || override?.lvl30) {
+      result.lvl30 = { ...(baseStats?.lvl30 ?? {}), ...(override?.lvl30 ?? {}) };
+    }
+    for (const key of Object.keys(override ?? {})) {
+      if (key === 'lvl1' || key === 'lvl30') continue;
+      result[key] = override[key];
+    }
+    return result;
+  }
+
+  function pickImage(preferred: any, fallback: any) {
+    if (Array.isArray(preferred)) return preferred.slice();
+    if (preferred != null) return preferred;
+    if (Array.isArray(fallback)) return fallback.slice();
+    return fallback ?? [];
+  }
+
+  function mapSkin(s: any, lookup: BaseMap, index: number) {
+    const key = baseId(s?.id);
+    const base = key ? lookup.get(key) : undefined;
+
+    const merged: any = {
+      ...(base ?? {}),
+      ...(s ?? {}),
+      id: s?.id ?? base?.id,
+      name: s?.name ?? base?.name,
+      genes: Array.isArray(s?.genes) && s.genes.length ? s.genes : base?.genes,
+      base_stats: mergeBaseStats(base?.base_stats, s?.base_stats),
+      image: pickImage(s?.image, base?.image),
+      type: s?.type ?? base?.type ?? 'default',
       star: !s?.star || s.star === 'none' ? 'normal' : String(s.star).toLowerCase(),
-      bingo: Array.isArray(s?.bingo) || typeof s?.bingo === 'object' ? s.bingo : [],
-      skin: s?.skin ?? true,
+      bingo: hasBingo(s?.bingo) ? s.bingo : base?.bingo,
+      abilities: Array.isArray(s?.abilities) && s.abilities.length ? s.abilities : base?.abilities,
+      name_attack1: s?.name_attack1 ?? base?.name_attack1,
+      name_attack2: s?.name_attack2 ?? base?.name_attack2,
+      name_lore: s?.name_lore ?? base?.name_lore,
+      incub_time:
+        s?.incub_time ??
+        s?.incubation ??
+        s?.incubation_time ??
+        s?.incubationTime ??
+        s?.incubation_hours ??
+        s?.hatch_time ??
+        base?.incub_time ??
+        base?.incubation ??
+        base?.incubation_time ??
+        base?.incubationTime ??
+        base?.incubation_hours ??
+        base?.hatch_time,
+      chance: s?.chance ?? s?.chance_percent ?? base?.chance ?? base?.chance_percent,
+      tier: s?.tier ?? base?.tier,
+      skin: s?.skin ?? base?.skin ?? true,
       __source: 'skin' as const,
+      __skinIndex: index,
+      __skinKey: `${key || 'skin'}::${String(s?.skin ?? '')}::${index}`,
     };
+
+    return merged;
   }
-  $: normalizedSkins = (Array.isArray(skins) ? skins : []).map(mapSkin);
+
+  let baseMap: BaseMap = new Map();
+  $: baseMap = buildBaseMap(items ?? []);
+  $: normalizedSkins = (Array.isArray(skins) ? skins : []).map((skin, index) => mapSkin(skin, baseMap, index));
 
   // ===========
   // КОНТРОЛЫ UI
   // ===========
   // Режимы отображения
   type Mode = 'mutants' | 'skins';
   let mode: Mode = 'mutants';
 
   // Поиск/фильтры МУТАНТОВ
   let query = '';
   let gene1Sel = '';
   let gene2Sel = '';
   $: geneSel = [gene1Sel, gene2Sel].filter(Boolean).sort().join(''); // 'AB' | 'A' | ''
 
   // Типы/бинго считаем по items (мустантам)
   function uniq<T>(arr: T[]) { return Array.from(new Set(arr)); }
   $: typeOptions = uniq(items.map(it => it?.type).filter(Boolean))
       .sort((a:any,b:any) => String(TYPE_RU?.[a] ?? a).localeCompare(String(TYPE_RU?.[b] ?? b), 'ru'));
   let typeSel = '';
 
   function collectBingoKeys(it:any): string[] {
     const b = it?.bingo;
     if (!b) return [];
     if (Array.isArray(b)) return b.map((x:any) => typeof x === 'string' ? x : (x?.key ?? '')).filter(Boolean);
     if (typeof b === 'object') return Object.keys(b);
@@ -91,115 +172,148 @@
 
   // По умолчанию: мутанты = только обычные; скины = любые
   let starSelMutants: StarKey = 'normal';
   let starSelSkins: SkinStarKey = 'any';
 
   // Переход режимов: подстраиваем дефолты
   function switchTo(next: Mode) {
     mode = next;
     if (mode === 'mutants') {
       if (!['normal','bronze','silver','gold','platinum'].includes(starSelMutants)) starSelMutants = 'normal';
     } else {
       if (!['any','normal','bronze','silver','gold','platinum'].includes(starSelSkins)) starSelSkins = 'any';
     }
   }
 
   // Гены — иконки (public/genes)
   const geneList = [
     { key: '',  label: 'Все',                   icon: '/genes/icon_gene_all.png' },
     { key: 'A', label: geneLabel?.('A') ?? 'A', icon: '/genes/icon_gene_a.png' },
     { key: 'B', label: geneLabel?.('B') ?? 'B', icon: '/genes/icon_gene_b.png' },
     { key: 'C', label: geneLabel?.('C') ?? 'C', icon: '/genes/icon_gene_c.png' },
     { key: 'D', label: geneLabel?.('D') ?? 'D', icon: '/genes/icon_gene_d.png' },
     { key: 'E', label: geneLabel?.('E') ?? 'E', icon: '/genes/icon_gene_e.png' },
     { key: 'F', label: geneLabel?.('F') ?? 'F', icon: '/genes/icon_gene_f.png' },
   ];
+  const geneButtonClass = (selected: boolean) =>
+    'p-1 rounded-lg ring-1 ' + (selected ? 'bg-cyan-700 ring-cyan-400' : 'bg-slate-800 ring-white/10');
 
   // =================
   // ПОМОЩНИКИ ФИЛЬТРОВ
   // =================
   const normalizeGene = (s:string) => (s ?? '').toUpperCase().split('').sort().join('');
   const starOf = (it:any) => String(it?.star ?? 'normal').toLowerCase();
   function readGeneCode(it:any): string {
     if (Array.isArray(it?.genes) && typeof it.genes[0] === 'string') return it.genes[0];
     if (typeof it?.gene === 'string') return it.gene;
     if (typeof it?.gene_code === 'string') return it.gene_code;
     return '';
   }
+  const geneOrder = new Map<string, number>([
+    ['A', 0],
+    ['B', 1],
+    ['C', 2],
+    ['D', 3],
+    ['E', 4],
+    ['F', 5],
+  ]);
+  function geneSortTuple(it: any) {
+    const code = normalizeGene(readGeneCode(it));
+    const first = code?.[0] ?? '';
+    const rank = first ? geneOrder.get(first) ?? 99 : 199;
+    return { rank, code, name: String(it?.name ?? '') };
+  }
+  function compareByGene(a: any, b: any) {
+    const ga = geneSortTuple(a);
+    const gb = geneSortTuple(b);
+    if (ga.rank !== gb.rank) return ga.rank - gb.rank;
+    if (ga.code !== gb.code) return ga.code.localeCompare(gb.code, 'ru');
+    return ga.name.localeCompare(gb.name, 'ru');
+  }
   const isSkin = (it:any) =>
     it?.__source === 'skin' || typeof it?.skin !== 'undefined';
-  const keyOf  = (it:any) => (isSkin(it) ? `skin:${it.id}` : `mut:${it.id}`);
+  const keyOf  = (it:any, index?: number) => {
+    if (isSkin(it)) {
+      if (typeof it?.__skinKey === 'string') return `skin:${it.__skinKey}`;
+      const key = baseId(it?.id);
+      const variant = it?.skin ?? index ?? '';
+      return `skin:${key}:${variant}:${index ?? 0}`;
+    }
+    return `mut:${it?.id ?? index}`;
+  };
 
   // ==========
   // WORKER и быстрый пересчёт (сокращено для контекста ответа)
   // ==========
   let useWorker = false; // твой текущий флаг
   let worker: Worker | null = null;
   let computeVersion = 0;
   let inFlight = false;
   let queued = false;
 
   let _workerTotal = 0;
   let filteredMutantsWorkerSlice: any[] = [];
 
   // (инициализация воркера/сообщения пропущу — оставляю как в твоём файле)
   // ...
 
   // ===========
   // ФИЛЬТРАЦИЯ
   // ===========
   $: filteredMutants = useWorker
     ? new Array(_workerTotal)
     : memo(
         JSON.stringify({q: query, t: typeSel, g: geneSel, b: bingoSel, star: starSelMutants, n: items?.length ?? 0}),
         () => items
           .filter(it => !query || String(it?.name ?? '').toLowerCase().includes(query.toLowerCase()))
           .filter(it => !typeSel || String(it?.type ?? '') === typeSel)
           .filter(it => {
             if (!bingoSel) return true;
             const keys = new Set(collectBingoKeys(it).map(String));
             return keys.has(String(bingoSel));
           })
           .filter(it => !geneSel || normalizeGene(readGeneCode(it)) === geneSel)
           .filter(it => {
             const k = starSelMutants;
             return k === 'normal' ? starOf(it) === 'normal' : starOf(it) === k;
           })
           .slice()
-          .sort((a:any,b:any) => String(a?.name ?? '').localeCompare(String(b?.name ?? ''), 'ru'))
+          .sort(compareByGene)
       );
 
   $: filteredSkins = memo(
-    JSON.stringify({star: starSelSkins, n: normalizedSkins?.length ?? 0}),
+    JSON.stringify({q: query, gene: geneSel, star: starSelSkins, n: normalizedSkins?.length ?? 0}),
     () => normalizedSkins
+      .filter(it => !query || String(it?.name ?? '').toLowerCase().includes(query.toLowerCase()))
+      .filter(it => !geneSel || normalizeGene(readGeneCode(it)) === geneSel)
       .filter(it => {
         const k = starSelSkins;
         if (k === 'any') return true;
         return k === 'normal' ? starOf(it) === 'normal' : starOf(it) === k;
       })
       .slice()
-      .sort((a:any,b:any) => String(a?.name ?? '').localeCompare(String(b?.name ?? ''), 'ru'))
+      .sort(compareByGene)
   );
 
   // ===== Пагинация «Показать ещё» =====
   let pageSize = 60;
   let currentPage = 1;
   $: resetKey = JSON.stringify({ mode, query, geneSel, typeSel, bingoSel, starSelMutants, lenM: items?.length ?? 0, lenS: normalizedSkins?.length ?? 0 });
   $: if (resetKey) { currentPage = 1; }
   $: endIndex = pageSize * currentPage;
   $: shownMutants = useWorker ? filteredMutantsWorkerSlice : filteredMutants.slice(0, endIndex);
   $: shownSkins = filteredSkins.slice(0, endIndex);
 
   // =========
   // ПРОЧЕЕ
   // =========
   function pickTexture(it:any): string {
     const list = Array.isArray(it?.image) ? it.image : (it?.image ? [it.image] : []);
     const pick =
       list.find((p:string) => p.includes('textures_by_mutant/') && !p.includes('specimen') && !p.includes('larva'))
       || list[0];
     return pick ?? 'placeholder-mutant.png';
   }
   function rarityType(item:any){
     const s = (item?.star ?? 'normal').toLowerCase();
     return ['bronze','silver','gold','platinum'].includes(s) ? s : 'normal';
   }
@@ -214,101 +328,91 @@
   {/if}
 
   <!-- Переключатель режимов -->
   <div class="mb-4 flex flex-wrap gap-2">
     <button type="button"
       class={'px-3 rounded-lg ring-1 h-8 text-[11px] uppercase tracking-wider '
         + (mode==='mutants' ? 'bg-cyan-700 ring-cyan-400 text-white' : 'bg-slate-800 ring-white/10 text-slate-200')}
       on:click={() => switchTo('mutants')}
       aria-pressed={mode==='mutants'}
     >
       MUTANTS
     </button>
     <button type="button"
       class={'px-3 rounded-lg ring-1 h-8 text-[11px] uppercase tracking-wider '
         + (mode==='skins' ? 'bg-cyan-700 ring-cyan-400 text-white' : 'bg-slate-800 ring-white/10 text-slate-200')}
       on:click={() => switchTo('skins')}
       aria-pressed={mode==='skins'}
     >
       SKINS
     </button>
   </div>
 
   <!-- Поиск -->
   <div class="mb-3">
     <input
-      class={'w-full px-4 py-3 rounded-lg ring-1 transition outline-none '
-        + (mode==='mutants'
-            ? 'bg-slate-900 text-slate-100 placeholder-slate-400 ring-white/10 focus:ring-2 focus:ring-cyan-400'
-            : 'bg-slate-800/60 text-slate-400 placeholder-slate-500 ring-white/10/30 pointer-events-none')}
-      placeholder={mode==='mutants' ? 'Введите имя мутанта…' : 'Поиск отключён для SKINS'}
+      class="w-full px-4 py-3 rounded-lg ring-1 transition outline-none bg-slate-900 text-slate-100 placeholder-slate-400 ring-white/10 focus:ring-2 focus:ring-cyan-400"
+      placeholder="Введите имя мутанта…"
       bind:value={query}
-      disabled={mode!=='mutants'}
     />
   </div>
 
-  <!-- Гены: две строки (только для MUTANTS; в SKINS заблокировано и приглушено) -->
- <div class="mb-2 rounded-xl bg-slate-900/60 ring-1 ring-white/10 p-2 shadow-sm md:shadow">
+  <!-- Гены: две строки -->
+  <div class="mb-2 rounded-xl bg-slate-900/60 ring-1 ring-white/10 p-2 shadow-sm md:shadow">
     <div class="flex flex-col gap-2">
       <div class="flex flex-wrap gap-2">
         {#each geneList as g}
           <button type="button"
-            class={'p-1 rounded-lg ring-1 '
-              + (mode==='mutants'
-                  ? (gene1Sel===g.key ? 'bg-cyan-700 ring-cyan-400' : 'bg-slate-800 ring-white/10')
-                  : 'bg-slate-800/60 ring-white/10/30 pointer-events-none')}
-            on:click={() => { if(mode==='mutants'){ gene1Sel = (g.key==='' ? '' : (gene1Sel===g.key ? '' : g.key)); } }}
+            class={geneButtonClass(gene1Sel===g.key)}
+            on:click={() => { gene1Sel = (g.key==='' ? '' : (gene1Sel===g.key ? '' : g.key)); }}
             title={g.label}
             aria-pressed={gene1Sel===g.key}
           >
             <img src={g.icon} alt={g.label} class="h-8 w-8 object-contain" />
           </button>
         {/each}
       </div>
       <div class="flex flex-wrap gap-2">
         {#each geneList as g}
           <button type="button"
-            class={'p-1 rounded-lg ring-1 '
-              + (mode==='mutants'
-                  ? (gene2Sel===g.key ? 'bg-cyan-700 ring-cyan-400' : 'bg-slate-800 ring-white/10')
-                  : 'bg-slate-800/60 ring-white/10/30 pointer-events-none')}
-            on:click={() => { if(mode==='mutants'){ gene2Sel = (g.key==='' ? '' : (gene2Sel===g.key ? '' : g.key)); } }}
+            class={geneButtonClass(gene2Sel===g.key)}
+            on:click={() => { gene2Sel = (g.key==='' ? '' : (gene2Sel===g.key ? '' : g.key)); }}
             title={g.label}
             aria-pressed={gene2Sel===g.key}
           >
             <img src={g.icon} alt={g.label} class="h-8 w-8 object-contain" />
           </button>
         {/each}
       </div>
     </div>
   </div>
 
   <!-- Редкость (иконки) -->
- <div class="mb-4 rounded-xl bg-slate-900/60 ring-1 ring-white/10 p-2 shadow-sm md:shadow">
-  {#if mode === 'mutants'}
-    <div class="flex flex-wrap gap-2">
-      {#each STAR_MUTANTS as s}
+  <div class="mb-4 rounded-xl bg-slate-900/60 ring-1 ring-white/10 p-2 shadow-sm md:shadow">
+    {#if mode === 'mutants'}
+      <div class="flex flex-wrap gap-2">
+        {#each STAR_MUTANTS as s}
           <button type="button"
             class={'px-2 h-8 rounded-lg ring-1 flex items-center gap-2 '
               + (starSelMutants===s.key ? 'bg-cyan-700 ring-cyan-400 text-white' : 'bg-slate-800 ring-white/10 text-slate-200')}
             on:click={() => (starSelMutants = s.key)}
             aria-pressed={starSelMutants===s.key}
           >
             <img src={s.icon} alt={s.label} class="h-5 w-5 object-contain" />
             <span class="text-xs">{s.label}</span>
           </button>
         {/each}
       </div>
     {:else}
       <div class="flex flex-wrap gap-2">
         {#each STAR_SKINS as s}
           <button type="button"
             class={'px-2 h-8 rounded-lg ring-1 flex items-center gap-2 '
               + (starSelSkins===s.key ? 'bg-cyan-700 ring-cyan-400 text-white' : 'bg-slate-800 ring-white/10 text-slate-200')}
             on:click={() => (starSelSkins = s.key)}
             aria-pressed={starSelSkins===s.key}
           >
             {#if s.icon}<img src={s.icon} alt={s.label} class="h-5 w-5 object-contain" />{/if}
             <span class="text-xs">{s.label}</span>
           </button>
         {/each}
       </div>
@@ -329,62 +433,62 @@
       >
         <option value=''>Любой</option>
         {#each typeOptions as t}<option value={t}>{TYPE_RU?.[t] ?? t}</option>{/each}
       </select>
     </label>
 
     <label class="flex flex-col gap-1">
       <span class="text-xs text-slate-300">Бинго</span>
       <select
         class={'px-3 py-2 rounded-lg ring-1 '
           + (mode==='mutants'
               ? 'bg-slate-900 text-slate-100 ring-white/10 focus:outline-none focus:ring-2 focus:ring-cyan-400'
               : 'bg-slate-800/60 text-slate-500 ring-white/10/30 pointer-events-none')}
         bind:value={bingoSel}
         disabled={mode!=='mutants'}
       >
         <option value=''>Любое</option>
         {#each bingoOptions as b}<option value={b}>{bingoLabel?.(b) ?? b}</option>{/each}
       </select>
     </label>
   </div>
 
   <!-- Сетка карточек -->
   <div class="grid gap-4 grid-cols-2 sm:grid-cols-3 md:grid-cols-4 xl:grid-cols-5 [content-visibility:auto]" style="contain-intrinsic-size: 1200px;">
     {#if mode === 'mutants'}
-      {#each shownMutants as it, i (keyOf(it))}
+      {#each shownMutants as it, i (keyOf(it, i))}
         <div role="button" tabindex="0" class="cursor-pointer" on:click={() => openModal(it)}>
           <div class="relative rounded-xl overflow-hidden bg-slate-800 ring-1 ring-white/10" style="content-visibility:auto; contain-intrinsic-size: 260px 340px;">
             <img class="w-full h-48 object-contain bg-slate-900" src={'/' + pickTexture(it)} alt={it.name} loading="lazy" decoding="async" fetchpriority={i < 12 ? 'high' : 'low'} width="512" height="512" />
             <div class="px-3 pt-2 pb-3">
               <div class="text-slate-100 font-semibold text-sm truncate">{it.name}</div>
             </div>
           </div>
         </div>
       {/each}
     {:else}
-      {#each shownSkins as it, i (keyOf(it))}
+      {#each shownSkins as it, i (keyOf(it, i))}
         <div role="button" tabindex="0" class="cursor-pointer" on:click={() => openModal(it)}>
           <div class="relative rounded-xl overflow-hidden bg-slate-800 ring-1 ring-white/10" style="content-visibility:auto; contain-intrinsic-size: 260px 340px;">
             <img class="w-full h-48 object-contain bg-slate-900" src={'/' + pickTexture(it)} alt={it.name} loading="lazy" decoding="async" fetchpriority={i < 12 ? 'high' : 'low'} width="512" height="512" />
             <div class="px-3 pt-2 pb-3">
               <div class="text-slate-100 font-semibold text-sm truncate">{it.name}</div>
             </div>
           </div>
         </div>
       {/each}
     {/if}
   </div>
 
   <!-- Показать ещё -->
   {#if mode === 'mutants'}
     {#if shownMutants.length < filteredMutants.length}
       <div class="mt-3 flex justify-center">
         <button class="px-3 py-1.5 rounded-lg bg-slate-800 hover:bg-slate-700 ring-1 ring-white/10 text-white"
                 on:click={() => { currentPage = currentPage + 1; }}>
           Показать ещё
         </button>
       </div>
     {/if}
   {:else}
     {#if shownSkins.length < filteredSkins.length}
       <div class="mt-3 flex justify-center">
diff --git a/src/components/breeding/BreedingUI.svelte b/src/components/breeding/BreedingUI.svelte
index dce6cf314d97b7fc5ce65856715c78e80d860d96..ac23e4030a5af083809fc06d3253a54b30790d61 100644
--- a/src/components/breeding/BreedingUI.svelte
+++ b/src/components/breeding/BreedingUI.svelte
@@ -193,63 +193,122 @@ import mutantsData from '@/data/mutants/normal.json';
       if (excluded.includes(type)) return false;
       // Default types and explicitly named legends are always breedable
       if (type === 'default' || alwaysBreedableLegends.includes(name)) return true;
       // All other types require the mutant itself to be one of the parents
       if (selectedA && selectedA.id === m.id) return true;
       if (selectedB && selectedB.id === m.id) return true;
       return false;
     });
   }
 
   /**
    * Mapping of gene letters to tailwind background color classes. These
    * approximate the colored gene icons seen in the m3guide reference. If a
    * gene character isn't found in this map, a neutral gray will be used.
    */
   const geneColors: Record<string, string> = {
     a: 'bg-yellow-500',
     b: 'bg-red-500',
     c: 'bg-purple-600',
     d: 'bg-blue-500',
     e: 'bg-green-500',
     f: 'bg-pink-500',
   };
 
   /**
-   * Convert an incubation time value from the dataset into a human-readable
-   * string. Times less than 10 are treated as minutes; times up to 24 as
-   * hours; larger values are converted to days. Units use Russian letters to
-   * match the screenshot (м — minutes, ч — hours, д — days).
+   * Fields that may contain incubation information in the mutants dataset.
+   * Skins and legacy entries occasionally store the value under an alternate
+   * property, so we mirror the precedence used in the main mutants browser.
    */
-  function formatIncubationTime(time: any): string {
-    const n = Number(time);
-    if (!isFinite(n) || n <= 0) return '';
-    if (n < 10) return `${n}м`;
-    // Treat values less than 48 as hours. Some dataset values like 25 should be read as 25 hours.
-    if (n < 48) return `${n}ч`;
-    const days = Math.floor(n / 24);
-    return `${days}д`;
+  const incubationFields = [
+    'incub_time',
+    'incubation',
+    'incubation_time',
+    'incubationTime',
+    'incubation_hours',
+    'hatch_time',
+  ];
+
+  /**
+   * Extract the raw incubation value from a mutant or direct value. When an
+   * object is supplied we probe the known property names, otherwise the
+   * argument itself is treated as the incubation value.
+   */
+  function resolveIncubationValue(source: any): any {
+    if (source == null) return null;
+    if (typeof source === 'object' && !Array.isArray(source)) {
+      for (const field of incubationFields) {
+        const value = source?.[field];
+        if (value != null && value !== '') return value;
+      }
+      return null;
+    }
+    return source;
+  }
+
+  /**
+   * Convert a raw incubation value to minutes. Most datasets already provide
+   * minutes, but we also handle string values that may include units or use
+   * commas as decimal separators. Hours or days are converted to minutes.
+   */
+  function coerceMinutes(value: any): number | null {
+    if (value == null || value === '') return null;
+    if (typeof value === 'number') {
+      return Number.isFinite(value) ? value : null;
+    }
+    if (typeof value === 'string') {
+      const trimmed = value.trim();
+      if (!trimmed) return null;
+      const normalized = trimmed.replace(',', '.');
+      const match = normalized.match(/[-+]?[0-9]*\.?[0-9]+/);
+      if (!match) return null;
+      const numeric = Number(match[0]);
+      if (!Number.isFinite(numeric)) return null;
+      if (/дн/i.test(normalized)) return numeric * 24 * 60;
+      if (/час/i.test(normalized) && !/мин/i.test(normalized)) return numeric * 60;
+      return numeric;
+    }
+    return null;
+  }
+
+  /**
+   * Resolve the incubation duration (in minutes) from a mutant entry or value.
+   */
+  function getIncubationMinutes(source: any): number | null {
+    const raw = resolveIncubationValue(source);
+    return coerceMinutes(raw);
+  }
+
+  /**
+   * Format an incubation value to the "мин." representation used across the
+   * site. Accepts either a mutant object or a direct value.
+   */
+  function formatIncubationTime(source: any): string {
+    const minutes = typeof source === 'object' ? getIncubationMinutes(source) : coerceMinutes(source);
+    if (minutes == null) return '';
+    if (!Number.isFinite(minutes) || minutes <= 0) return '';
+    return `${Math.round(minutes)} мин.`;
   }
 
   /**
    * Derive a user-friendly category label and associated color class from a
    * mutant's type. Categories loosely follow the naming conventions found in
    * m3guide. Unknown types fall back to a neutral gray.
    */
   function getCategory(m: any): { label: string; color: string } {
     const type = (m.type ?? '').toLowerCase();
     switch (type) {
       case 'default':
         return { label: 'Обычный', color: 'bg-gray-400' };
       case 'legend':
         return { label: 'Легенда', color: 'bg-yellow-600' };
       case 'special':
         return { label: 'Особый', color: 'bg-teal-600' };
       case 'heroic':
         return { label: 'Герой', color: 'bg-red-600' };
       case 'seasonal':
         return { label: 'Сезон', color: 'bg-blue-600' };
       case 'pvp':
         return { label: 'PVP', color: 'bg-purple-600' };
       default:
         return { label: m.type ?? '—', color: 'bg-gray-600' };
     }
@@ -262,52 +321,52 @@ import mutantsData from '@/data/mutants/normal.json';
    * mutants into `childResults`. Otherwise the array is empty. This array
    * drives the results table in the markup.
    */
   let childResults: any[] = [];
   $: if (mode === 'calc' && selectedA && selectedB) {
     const codes = getChildGeneCodes(selectedA.genes, selectedB.genes);
     const map = new Map<string, any>();
     codes.forEach((code) => {
       const list = lookupChildren(code, selectedA, selectedB);
       list.forEach((m) => {
         if (!map.has(m.id)) map.set(m.id, m);
       });
     });
     childResults = Array.from(map.values());
   } else {
     childResults = [];
   }
 
   /**
    * Derived breeding time estimate. When both parents are selected and there
    * are children, choose the minimum incubation time among children for display.
    */
   let breedingTime: string = '';
   $: if (selectedA && selectedB && childResults.length > 0) {
     const times = childResults
-      .map((m) => Number(m.incub_time))
-      .filter((n) => isFinite(n) && n > 0)
+      .map((m) => getIncubationMinutes(m))
+      .filter((n): n is number => n != null && Number.isFinite(n) && n > 0)
       .sort((a, b) => a - b);
     if (times.length > 0) {
       breedingTime = formatIncubationTime(times[0]);
     } else {
       breedingTime = '';
     }
   } else {
     breedingTime = '';
   }
 
   // ---------------------------------------------------------------------------
   // UI state variables
   // ---------------------------------------------------------------------------
 
   /**
    * The calculator has two modes: 'calc' for forward breeding (parent → child)
    * and 'reverse' for breeding guide (child → parent combos). Switching
    * modes will reset selections and search state accordingly.
    */
   let mode: 'calc' | 'reverse' = 'calc';
 
   /** Selected parent mutants for calculation mode. When both parents are
    * assigned, results are computed automatically. */
   let selectedA: any = null;
   let selectedB: any = null;
@@ -605,51 +664,51 @@ import mutantsData from '@/data/mutants/normal.json';
                     <td class="px-3 py-1">
                       <img src={getImageSrc(child)} alt={getName(child)} class="w-8 h-8 rounded object-cover" />
                     </td>
                     <td class="px-3 py-1 whitespace-nowrap">{getName(child)}</td>
                     <td class="px-3 py-1">
                       <div class="flex space-x-1">
                         {#each ((Array.isArray(child.genes) ? child.genes[0] : child.genes) || '').split('') as ch}
                           <img src={getGeneIconSrc(ch)} alt={ch} class="w-6 h-6" />
                         {/each}
                       </div>
                     </td>
                     <td class="px-3 py-1">
                       {#if Array.isArray(child.bingo) && child.bingo.length > 0}
                         <!-- Use the morphology icon for all bingo groups for simplicity -->
                         <img src="/mut_icons/icon_morphology.png" alt="bingo" class="w-6 h-6" />
                       {:else}
                         —
                       {/if}
                     </td>
                     <td class="px-3 py-1">
                       <img src={getTypeIcon(child)} alt={child.type} class="w-6 h-6" />
                     </td>
                     <td class="px-3 py-1">
                       <span class={`inline-block px-2 py-1 rounded-full text-xs font-semibold text-gray-900 ${getCategory(child).color}`}>{getCategory(child).label}</span>
                     </td>
-                    <td class="px-3 py-1 whitespace-nowrap">{formatIncubationTime(child.incub_time)}</td>
+                    <td class="px-3 py-1 whitespace-nowrap">{formatIncubationTime(child)}</td>
                   </tr>
                 {/each}
               </tbody>
             </table>
           {:else}
             <div class="bg-gray-800 border border-gray-700 rounded-lg px-4 py-3 text-gray-400">
               Нет возможных детей для выбранных родителей.
             </div>
           {/if}
         </div>
       {/if}
     {:else}
       <!-- Reverse search mode -->
       <div class="mb-8">
         <label class="block font-bold mb-2">Выберите целевого мутанта</label>
         {#if selectedTarget}
           <div
             class="border border-gray-600 rounded-lg bg-gray-800 p-4 flex items-center space-x-3 relative cursor-pointer"
             on:click={() => { clearTarget(); }}
           >
             <img src={getImageSrc(selectedTarget)} alt={getName(selectedTarget)} class="w-16 h-16 rounded object-cover" />
             <span class="text-sm font-semibold">{getName(selectedTarget)}</span>
             <button class="absolute top-2 right-2 text-gray-400 hover:text-white">
               ×
             </button>
diff --git a/src/pages/miniapp/mutants.html b/src/pages/miniapp/mutants.html
index cd06fd0a62d2db8cad1a0f406ac9dc583a82a1b5..0cfbb1c5398c8ce57ba9f9a40fcc42772babdf51 100644
--- a/src/pages/miniapp/mutants.html
+++ b/src/pages/miniapp/mutants.html
@@ -252,39 +252,39 @@
       } catch (err) {
         return false;
       }
     }
 
     /**
      * Отрисовать список мутантов, соответствующих фильтру.
      */
     function renderMutants(mutants, filterParams) {
       const content = document.getElementById('content');
       content.innerHTML = '';
       const matching = mutants.filter((m) => matchesFilter(m, filterParams.filter, filterParams.value, filterParams.tol));
       if (!matching.length) {
           content.textContent = 'Нет мутантов, подходящих под выбранный фильтр.';
           return;
       }
       for (const m of matching) {
         const div = document.createElement('div');
         div.className = 'mutant';
         div.innerHTML = `
           <h2>${m.name}</h2>
           <p><strong>ID:</strong> ${m.id}</p>
           <p><strong>Гены:</strong> ${Array.isArray(m.genes) ? m.genes.join(', ') : m.genes || '-'}</p>
           <p><strong>Скорость:</strong> ${m.base_stats?.lvl1?.spd ?? '-'}</p>
           <p><strong>HP:</strong> ${m.base_stats?.lvl1?.hp ?? '-'}, <strong>Атака 1:</strong> ${m.base_stats?.lvl1?.atk1 ?? '-'}, <strong>Атака 2:</strong> ${m.base_stats?.lvl1?.atk2 ?? '-'}</p>
-          <p><small>Тиер: ${m.tier || '-'}; Инкубация: ${m.incub_time || '-'} дн.; Звезда: ${m.star || '-'}</small></p>
+          <p><small>Тиер: ${m.tier || '-'}; Инкубация: ${m.incub_time || '-'} мин.; Звезда: ${m.star || '-'}</small></p>
         `;
         content.appendChild(div);
       }
     }
 
     (async () => {
       const filterParams = getFilterParams();
       const mutants = await loadMutants();
       renderMutants(mutants, filterParams);
     })();
   </script>
 </body>
 </html>
